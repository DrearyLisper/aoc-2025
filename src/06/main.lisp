(defpackage :day06
  (:use :cl :arrows)
  (:import-from :trivia #:match)
  (:export #:main))

(in-package :day06)

(defun part01 (content)
  (labels ((parse-line (line)
             (-<> (str:split " " line)
                  (map 'list #'str:trim <>)
                  (remove-if #'str:empty? <>)))
           (parse-integers (line)
             (map 'list #'parse-integer line))
           (execute (operation &rest args)
             (match operation
               ("*" (apply #'* args))
               ("+" (apply #'+ args))))
           (parse (content)
             (let*  ((lines (-<> (str:lines (str:trim content))
                                 (map 'list #'parse-line <>))))
               (cons #'execute
                     (cons (first (last lines))
                           (-<> (butlast lines)
                                (map 'list #'parse-integers <>)))))))
    (-<> (parse content)
         (apply #'mapcar <>)
         (apply #'+ <>))))

(defun part02 (content)
  (labels ((pad (n)
             (lambda (line)
               (str:concat line (make-string  (- n (length line)) :initial-element #\space))))
           (parse (content)
             (-<> (str:lines content)
                  (map 'list (pad
                              (apply #'max (map 'list #'length (str:lines content)))) <>)
                  (map 'list (lambda (l) (coerce l 'vector)) <>)))
           (access (line p)
             (if (< p (length line))
                 (aref line p)
                 #\space))
           (read-column (lines p)
             (let  ((column (-<> (loop for l in lines collect (access l p))
                                 (coerce <> 'string)
                                 (str:trim <>))))
               (if (str:empty? column)
                   nil
                   (parse-integer column))))
           (read-whole (lines p so-far)
             (match (list (equal (length (first lines)) p) (read-column lines p))
               ((list t _) (list so-far))
               ((list _ nil) (cons so-far (read-whole lines (1+ p) nil)))
               ((list _ i) (read-whole lines (1+ p) (cons i so-far)))))
           (execute (args)
             (match (first args)
               ("*" (apply #'* (rest args)))
               ("+" (apply #'+ (rest args)))))
           )

    (let*  ((parsed (parse content))
            (blocks (read-whole (butlast parsed) 0 nil))
            (operations (-<> (str:split " " (first (last parsed)))
                             (map 'list #'str:trim <>)
                             (remove-if #'str:empty? <>)
                             (map 'list #'list <>))))
      (-<> (apply #'mapcar (list #'execute (mapcar #'append operations blocks)))
           (apply #'+ <>)))))

(defun main ()
  (let ((content (utils:read-input "06")))
    (format t "~S~%" (part01 content))
    (format t "~S~%" (part02 content))))
